require('dotenv').config();
const fetchKPI = require('./fetchKPI');
const KPI = require('../models/KPI');

function buildJobsFromEnv() {
  const A = (process.env.FUSION_A_USERNAME && process.env.FUSION_A_PASSWORD && process.env.FUSION_A_PLANT_NAME) ? {
    sourceKey:  process.env.FUSION_A_SOURCE || 'A',
    baseUrl:    process.env.FUSION_BASE_URL,
    userName:   process.env.FUSION_A_USERNAME,
    systemCode: process.env.FUSION_A_PASSWORD,
    plantName:  process.env.FUSION_A_PLANT_NAME,
  } : null;

  const B = (process.env.FUSION_B_USERNAME && process.env.FUSION_B_PASSWORD && process.env.FUSION_B_PLANT_NAME) ? {
    sourceKey:  process.env.FUSION_B_SOURCE || 'B',
    baseUrl:    process.env.FUSION_BASE_URL,
    userName:   process.env.FUSION_B_USERNAME,
    systemCode: process.env.FUSION_B_PASSWORD,
    plantName:  process.env.FUSION_B_PLANT_NAME,
  } : null;

  return [A, B].filter(Boolean);
}

const sleep = (ms) => new Promise(r => setTimeout(r, ms));

// ‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏ó‡∏¢ ‚Üí UTC ‡∏Ç‡∏≠‡∏á ‚Äú‡πÄ‡∏ó‡∏µ‡πà‡∏¢‡∏á‡∏Ñ‡∏∑‡∏ô‡∏ß‡∏±‡∏ô‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ (‡πÑ‡∏ó‡∏¢)‚Äù
const BKK_OFFSET_MS = 7 * 60 * 60 * 1000;
function bkkYYYYMMDD(d) { return d.toLocaleDateString('en-CA', { timeZone: 'Asia/Bangkok' }); }
function startOfBkkDayUTC(dateUtc = new Date()) {
  const [y,m,day] = bkkYYYYMMDD(dateUtc).split('-').map(Number);
  return new Date(Date.UTC(y, m-1, day) - BKK_OFFSET_MS);
}
function startOfBkkTomorrowUTC() {
  return new Date(startOfBkkDayUTC().getTime() + 24*60*60*1000);
}

// ‡∏Å‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á retry ‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ï‡πà‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ
const retryFlags = new Map(); 
function dayKey(date = new Date()) { return bkkYYYYMMDD(date); }

async function scheduleRetry(cfg, saveToDB, delayMs = 30 * 60 * 1000) {
  const key = `${cfg.sourceKey}:${dayKey()}`;
  if (retryFlags.get(key)) {
    console.log(`‚Ü©Ô∏é [${cfg.sourceKey}] Retry already scheduled for today, skip`);
    return;
  }
  retryFlags.set(key, true);

  console.log(`‚è≤Ô∏è  [${cfg.sourceKey}] Schedule retry in ${Math.round(delayMs/60000)} minutes...`);
  setTimeout(async () => {
    try {
      console.log(`üîÅ [${cfg.sourceKey}] Retry fetch now (after 30 min)`);
      //  ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡πá‡πÑ‡∏°‡πà‡∏î‡∏∂‡∏á
      const tomorrow = startOfBkkTomorrowUTC();
      const exists = await KPI.exists({ sourceKey: cfg.sourceKey, appliesToDate: tomorrow });
      if (exists) {
        console.log(`‚úÖ [${cfg.sourceKey}] Already present for tomorrow ‚Äî skip retry fetch`);
        return;
      }
      await fetchKPI(cfg, saveToDB);
    } catch (e) {
      console.error(`‚ùå [${cfg.sourceKey}] Retry error:`, e?.message || e);
    }
  }, delayMs);
}

async function fetchAll(saveToDB = true) {
  const jobs = buildJobsFromEnv();
  if (jobs.length === 0) {
    console.warn('‚ö†Ô∏è No station jobs defined in .env (use FUSION_A_* / FUSION_B_*)');
    return;
  }

  const tomorrow = startOfBkkTomorrowUTC();

  for (const cfg of jobs) {
    // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ç‡∏≠‡∏á‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏¢‡∏¥‡∏á API
    const exists = await KPI.exists({ sourceKey: cfg.sourceKey, appliesToDate: tomorrow });
    if (exists) {
      console.log(`üü° [${cfg.sourceKey}] KPI for tomorrow already exists ‚Äî skip fetch`);
    } else {
      const res = await fetchKPI(cfg, saveToDB);
      if (!res) {
        // ‡∏î‡∏∂‡∏á‡∏û‡∏•‡∏≤‡∏î ‡∏ï‡∏±‡πâ‡∏á retry 30 ‡∏ô‡∏≤‡∏ó‡∏µ
        await scheduleRetry(cfg, saveToDB);
      }
      // ‡∏Å‡∏±‡∏ô rate-limit ‡∏´‡∏ô‡πà‡∏ß‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏µ
      await sleep(15000);
    }
  }
}

module.exports = fetchAll;
